#solution3

-------------
problem A:
简单的找规律，递归什么的都可以做，应该没啥问题

problem B:
主要思想有两个： 1.找递推项规律 2.暴力dp
暴力dp的一种思路: dp[i][j] 表示假设是2*i 的矩阵， 第i列元素在第j次的时候被放入整个序列，除了 dp[1][j]之外，其他的都是由 dp[i - 1][1] ... dp[i - 1][j - 1] 的前缀和得到。根据这种想法去dp

递推项公式： a[i+1]=((ll)a[i]*(8*i+4))%mod;



problem C:
不说仙人掌树这种高端速录， 给出两个很平民的思路:
1. 两遍bfs，第一次正序bfs，第二次倒序bfs， 第一次可以保证顺时针的结果，第二次可以保证逆时针的结果。两者取最小(睿智)
2. 将成环的节点都提出来，可以O(1)地计算环上的距离。将环的边都去掉，形成一个森林。对于q(i, j)， 如果i，j的根在同一个环上节点上， 则使用LCA(i, j)就是ij距离， 如果i的根是ri, j的根是rj，ri != rj,那么ij距离就是 (i到根的距离+ j到根的距离 + 环上(ri, rj)距离)

problem D:
貌似是个dp，往dp的方向想应该可做。初步设想是构造高一个二维数组，一个维度保存一下是否已经去掉了边

problem E:

problem F:

problem G:
简单的查分约束。有板子就可以过。

problem H:
简单的模拟，应该是第三个水题。
